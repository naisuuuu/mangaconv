package imgutil_test

import (
	"image"
	"testing"

	"github.com/google/go-cmp/cmp"

	"github.com/naisuuuu/mangaconv/imgutil"
)

func TestGrayscale(t *testing.T) {
	tests := []struct {
		name string
		src  image.Image
		want *image.Gray
	}{
		{
			name: "Gray",
			src: &image.Gray{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(-1, -1, 11, 2),
			},
			want: &image.Gray{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(0, 0, 12, 3),
			},
		},
		{
			// This happens when reading grayscale .jpg files.
			name: "Gray - extra bytes",
			src: &image.Gray{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(-1, -1, 7, 1),
			},
			want: &image.Gray{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(0, 0, 8, 2),
			},
		},
		{
			name: "RGBA",
			src: &image.RGBA{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(-1, -1, 2, 2),
			},
			want: &image.Gray{
				Pix:    []uint8{0x3d, 0x78, 0x17, 0x1e, 0x25, 0x66, 0x0, 0x33, 0xff},
				Stride: 3,
				Rect:   image.Rect(0, 0, 3, 3),
			},
		},
		{
			name: "RGBA64",
			src: &image.RGBA64{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02,
					0x00, 0x00, 0xcc, 0x03, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff,
					0xaa, 0x33, 0xbb, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff,
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 4 * 4,
				Rect:   image.Rect(-1, -1, 1, 2),
			},
			want: &image.Gray{
				Pix:    []uint8{0x3d, 0x77, 0x29, 0xb4, 0x6, 0xff},
				Stride: 2,
				Rect:   image.Rect(0, 0, 2, 3),
			},
		},
		{
			name: "NRGBA",
			src: &image.NRGBA{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 3 * 4,
				Rect:   image.Rect(-1, -1, 2, 2),
			},
			want: &image.Gray{
				Pix:    []uint8{0x0, 0x0, 0x0, 0x1e, 0x25, 0x66, 0x0, 0x33, 0xff},
				Stride: 3,
				Rect:   image.Rect(0, 0, 3, 3),
			},
		},
		{
			name: "NRGBA64",
			src: &image.NRGBA64{
				Pix: []uint8{
					0xcc, 0x00, 0x00, 0x01, 0x00, 0xcc, 0x00, 0x02,
					0x00, 0x00, 0xcc, 0x03, 0x00, 0x00, 0xcc, 0x03,
					0x11, 0x22, 0x33, 0xff, 0x33, 0x22, 0x11, 0xff,
					0xaa, 0x33, 0xbb, 0xff, 0xaa, 0x33, 0xbb, 0xff,
					0x00, 0x00, 0x00, 0xff, 0x33, 0x33, 0x33, 0xff,
					0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
				},
				Stride: 4 * 4,
				Rect:   image.Rect(-1, -1, 1, 2),
			},
			want: &image.Gray{
				Pix:    []uint8{0x0, 0x5f, 0x2, 0x84, 0x1, 0xff},
				Stride: 2,
				Rect:   image.Rect(0, 0, 2, 3),
			},
		},
		{
			name: "YCbCr",
			src:  mustReadImg("testdata/wikipe-tan-YCbCr.jpg"),
			want: mustBeGray(mustReadImg("testdata/wikipe-tan-Gray.png")),
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := imgutil.Grayscale(tt.src)

			// Special case for when passed image is already grayscale.
			// In such case we want to create a copy of it and avoid related pitfalls.
			if img, ok := tt.src.(*image.Gray); ok {
				if got == img {
					t.Error("got source image, want a copy")
				}
				if len(img.Pix) > 0 && &img.Pix[0] == &got.Pix[0] {
					t.Error("copied image points to the same underlying pixel array")
				}
			}

			// Special case for YCbCr images. This is difficult to test, as direct comparisons fail with
			// seemingly random bits misplaced. My best guess is compression?
			// The "real" test here is how the outcome looks, and I can't see any differences between this
			// and draw.Draw. For being roughly 350 times faster than the aforementioned, seems good enough.
			// If you have a better idea how to test this or know why direct comparisons fail like they do,
			// please submit an issue/PR!
			if _, ok := tt.src.(*image.YCbCr); ok {
				if !isWithinDeltaDiff(tt.want.Pix, got.Pix, 2) {
					t.Errorf("Grayscale() difference above acceptable delta")
				}
				return
			}

			if diff := cmp.Diff(tt.want, got); diff != "" {
				t.Errorf("Grayscale() mismatch (-want +got):\n%s", diff)
			}
		})
	}
}

func BenchmarkGrayscale(b *testing.B) {
	benchmarks := []struct {
		name string
		img  image.Image
	}{
		{"RGBA", mustReadImg("testdata/wikipe-tan-RGBA.png")},
		{"RGBA64", mustReadImg("testdata/wikipe-tan-RGBA64.png")},
		{"NRGBA", mustReadImg("testdata/wikipe-tan-NRGBA.png")},
		{"NRGBA64", mustReadImg("testdata/wikipe-tan-NRGBA64.png")},
		{"YCbCr", mustReadImg("testdata/wikipe-tan-YCbCr.jpg")},
		{"Gray", mustReadImg("testdata/wikipe-tan-Gray.png")},
	}
	for _, bb := range benchmarks {
		if !isImageType(bb.img, bb.name) {
			b.Fatalf("source image is not of type %s", bb.name)
		}
		b.Run(bb.name, func(b *testing.B) {
			for i := 0; i < b.N; i++ {
				imgutil.Grayscale(bb.img)
			}
		})
	}
}
